name: CI

on:
  push:
    branches:
      - master
env:
  NEW_FILENAME: "lambda_function.py"

jobs:
  job2:
    runs-on: ubuntu-latest  # windows-latest | macos-latest
    name: Test changed-files
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0  # OR "2" -> To retrieve the preceding commit.


      # Example 1
      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v37

      # NOTE: `since_last_remote_commit: true` is implied by default and falls back to the previous local commit.

      - name: 所有改变的文件
        run: |
          echo "Actor: ${{ toJson(steps) }}"
          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            echo "$file was changed"
          done
      - name: 只Added的文件
        run: |
          for file in ${{ steps.changed-files.outputs.added_files }}; do
            echo "$file" >> origin_Added_Modified.txt
            filename=$(basename "$file")
            echo "$filename" >> Added_Modified.txt
          done
          cat origin_Added_Modified.txt
      - name: 只Modified的文件
        run: |
          for file in ${{ steps.changed-files.outputs.modified_files }}; do
            echo "$file" >> origin_Added_Modified.txt
            filename=$(basename "$file")
            echo "$filename" >> Added_Modified.txt
          done
          cat origin_Added_Modified.txt
      - name: 只Deleted的文件
        run: |
          for file in ${{ steps.changed-files.outputs.deleted_files }}; do
            filename=$(basename "$file")
            if grep -q "$filename" Added_Modified.txt; then
              echo "Filename $filename already exists in Added_Modified.txt"
              exit 0
            fi
            echo "$filename" >> Deleted.txt
          done
          cat Deleted.txt
      - name: 得到绝对名称
        run: |
          while IFS= read -r line; do
            echo "$(basename "$line")"
          done < Added_Modified.txt > modified_file_names.txt
          cat modified_file_names.txt
      - name: 开始修改文件
        run: |
          for file in ${{ steps.changed-files.outputs.modified_files }}; do
            filename=$(basename "$file")
            mv "$file" "$(dirname "$file")/${{ env.NEW_FILENAME }}"
            echo "$filename was renamed to ${{ env.NEW_FILENAME }}"
            ls
            rm "$(dirname "$file")/${{ env.NEW_FILENAME }}"
          done
      - name: 只下载更新的文件
        uses: actions/checkout@v3
        with:
          sparse-checkout: |
            README.md
          sparse-checkout-cone-mode: false
